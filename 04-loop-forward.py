import numpy as np

def f(x):
    return 1 / (1 + np.exp(-x))


def simple_looped_nn_calc(n_layers, x, w, b):
    global h
    # Формируется входной массив - перемножения весов в каждом слое
    # Если первый слой, то входной массив равен вектору х
    # Если слой не первый, вход для текущего слоя равен
    # выходу предыдущего
    for l in range(n_layers - 1):
        if l == 0:
            node_in = x
        else :
            # формирует выходной массив для узлов в слое l + 1
            node_in = h
        # проходит по строкам массива весов
        h = np.zeros((w[l].shape[0], ))
        # считает сумму внутри активационной функции
        for i in range(w[l].shape[0]):
            # проходит по столбцам массива весов
            f_sum = 0
            for j in range(w[l].shape[1]):
                # добавляет смещение
                f_sum += w[l][i][j] * node_in[j]
            f_sum += b[l][i]
            # использует активационную функцию для расчета
            # i-го выхода, в данном случае h1, h2, h3
            h[i] = f(f_sum)
    return h


w1 = np.array([
  [0.2, 0.2, 0.2],
  [0.4, 0.4, 0.4],
  [0.6, 0.6, 0.6]
])

w2 = np.zeros((1, 3))
w2[0, : ] = np.array([0.5, 0.5, 0.5])

b1 = np.array([0.8, 0.8, 0.8])
b2 = np.array([0.2])

h = [0, 0, 0]

w = [w1, w2]
b = [b1, b2]
x = [1.5, 2.0, 3.0] # Рандомный входной вектор x

print(simple_looped_nn_calc(3, x, w, b))